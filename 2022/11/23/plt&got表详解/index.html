
<!DOCTYPE html>
<html lang="zn-CN">
    <head>
        <canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
        <script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
        <script src="/js/fireworks.min.js"></script>
        <canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
        <script src="/js/background.min.js"></script>
        <div id="cursor"></div>
        <link rel="stylesheet" href="/css/cursor.min.css">
        <script src="/js/cursor.min.js"></script>
        <meta charset="UTF-8" />
        <title>xi &amp; Blog</title>
        <meta name="author" content="enicky" />
        <meta name="description" content="一个萌新pwn手的小房间" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>XI &amp; BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;归雁</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;相系</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;归档</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;析构</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;一点惊鸿</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;XI &amp; BLOG</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">归雁</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">相系</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">归档</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">析构</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">一点惊鸿</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/23
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>PLT和GOT</p>
<ul>
<li>GOT（Global Offset Table）全局偏移表。存储导入变量的地址</li>
<li>PLT（Procedure Linkage Table）程序链接表。它有两个功能，要么在 <code>.got.plt</code> 节中拿到地址，并跳转。要么当 <code>.got.plt</code> 没有所需地址的时，触发「链接器」去找到所需地址，与常见导入的函数有关，如 read 等函数。</li>
<li><strong>.got.plt</strong>，这个是 GOT 专门为 PLT 专门准备的节。说白了，**.got.plt 中的值是 GOT 的一部分<strong>。它包含上述 PLT 表所需地址（已经找到的和需要去触发的），</strong>存储导入函数的地址**</li>
<li><strong>.plt.got</strong>，与动态链接有关系。</li>
</ul>
<p>以<code>puts</code>函数为例，定义一般是在<code>glibc</code>动态库，只有当程序运行起来的时候才可以去确定地址，而运行时进行重定位时无法修改<code>.text</code>段的地址的，只能将<code>puts</code></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D?fromModule=lemma_inlink">静态重定位</a>：即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D?fromModule=lemma_inlink">动态重定位</a>：它不是在程序装入内存时完成的，而是CPU每次访问内存时 由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80?fromModule=lemma_inlink">动态地址</a>变换机构（硬件）自动进行把相对地址转换为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80?fromModule=lemma_inlink">绝对地址</a>。动态重定位需要软件和硬件相互配合完成。</p>
<p>到<code>date</code>段，<code>got</code>表怎么知道<code>puts()</code>函数的真实地址呢，链接器会额外生成一小段代码，如下所示：</p>
<pre><code class="assembly">.text
...

// 调用printf的call指令
call printf_stub
...
printf_stub:
    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址
    jmp rax // 跳过去执行printf函数

.data
...
printf函数的储存地址,这里储存printf函数重定位后的地址
</code></pre>
<p>简言之，动态链接每个函数都需要两板斧：</p>
<ul>
<li>用来存放外部函数地址的数据段  –<strong>全局偏移表</strong>（GOT）</li>
<li>用来获取外部函数地址的代码  –<strong>程序链接表</strong>（PLT）</li>
</ul>
<blockquote>
<p>plt 表不是查询表，而是一块代码，这一块内容是与代码相关的。</p>
</blockquote>
<p><img src="X:\桌面记录文件夹\学习记录\内容\27f70ib020.jpeg"></p>
<p>可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址，那我们可以发现，在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址.</p>
<p>而获取正确地址依靠的正是重定位，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制：</p>
<p><strong>延迟绑定</strong></p>
<p>只有动态库函数在被调用时，才会地址解析和重定位工作，为此可以使用类似这样的代码来实现：</p>
<pre><code class="c">//一开始没有重定位的时候会将 printf@got 填成 lookup_printf 的地址
void printf@plt()
&#123;
address_good:
    jmp *printf@got   
lookup_printf:
    调用重定位函数查找 printf 地址，并写到 printf@got
    goto address_good;//再返回去执行address_good
&#125;
</code></pre>
<p>解析一下：函数执行的一开始，代码中的<code>print@plt</code>显示的是<code>lookup_printf</code>的地址，所以会先跳转到<code>lookup_printf</code>地址去执行<code>lookup_printf</code>来寻找真正的<code>printf</code>函数地址然后返回<code>address_good</code>处，然后执行真正的<code>printf</code>函数地址。</p>
<p>上面的情况是建立在不知道<code>printf</code>函数地址的前提下，如果曾调用过，<code>print@plt</code>处存放的是<code>printf</code>函数地址则直接调用即可。</p>
<pre><code class="assembly">Disassembly of section .plt:

080482d0 &lt;common@plt&gt;:
 80482d0:	ff 35 04 a0 04 08    	pushl  0x804a004
 80482d6:	ff 25 08 a0 04 08    	jmp    *0x804a008  跳转到_dl_runtime_resolve这个函数中查找运行时地址  它是got表的													第三项，所以可以看到该地址为08  而puts对应的got表的地址为0c
 80482dc:	00 00                	add    %al,(%eax)
    ...

080482e0 &lt;puts@plt&gt;:
 80482e0:	ff 25 0c a0 04 08    	jmp    *0x804a00c  从got表的第四项开始
 80482e6:	68 00 00 00 00       	push   $0x0   这个 push进去的实际上就是在 got 表中的索引
 80482eb:	e9 e0 ff ff ff       	jmp    80482d0 &lt;_init+0x28&gt;   又跳到最上面的 公共 plt

080482f0 &lt;__libc_start_main@plt&gt;:
 80482f0:	ff 25 10 a0 04 08    	jmp    *0x804a010
 80482f6:	68 08 00 00 00       	push   $0x8   每一个got表项对应的 push 的参数之间的间隔为8
 80482fb:	e9 d0 ff ff ff       	jmp    80482d0 &lt;_init+0x28&gt;
</code></pre>
<p>其中除第一个表项以外，plt 表的第一条都是跳转到对应的 got 表项，而 got 表项的内容我们可以通过 gdb 来看一下</p>
<p>[^如何查看]:先 <code>gdb 程序</code>然后&#96;&#96;b main<code>，再 </code>run<code>， 再 </code>x&#x2F;x jmp的那个地址&#96; 就可以）</p>
<p>，如果函数还没有执行的时候，这里的地址是对应 plt 表项的下一条命令，即 push 0x0（作为参数传入– 相应函数在 <code>rel.plt</code> 中的偏移）</p>
<p>第一次调用时的过程：</p>
<p>xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve（通过这个函数找到运行时函数的地址）</p>
<ol>
<li>_dl_runtime_resolve 是怎么知道要查找 printf 函数的？</li>
<li>_dl_runtime_resolve 找到 printf 函数地址之后，它怎么知道回填到哪个 GOT 表项？</li>
</ol>
<p>第一个问题，在 xxx@plt 中，我们在 jmp 之前 push 了一个参数，每个 xxx@plt 的 push 的操作数都不一样，那个参数就相当于函数的 id，告诉了 _dl_runtime_resolve 要去找哪一个函数的地址</p>
<p>第二个问题，看 .rel.plt 的位置就对应着 xxx@plt 里 jmp 的地址，该位置就是偏移量，使用<code>readelf -r plt</code>读取<code>elf</code>文件中重定位节信息</p>
<p><img src="C:\Users\呢实\AppData\Roaming\Typora\typora-user-images\image-20221123203550527.png" alt="image-20221123203550527"></p>
<blockquote>
<p>在 i386 架构下，除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存：</p>
<ul>
<li><strong>got [0]: 本 ELF 动态段 (.dynamic 段）的装载地址</strong></li>
<li><strong>got [1]：本 ELF 的 link_map 数据结构描述符地址</strong>，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息。</li>
<li><strong>got [2]：指向动态装载器中 _dl_runtime_resolve 函数的指针。</strong></li>
</ul>
</blockquote>
<p>接下来<strong>跟着大佬的流程图来走一遍：</strong>：</p>
<p>第一次调用时的：</p>
<p><img src="X:\桌面记录文件夹\photototot\PLT.GOT_two.jpeg"></p>
<p>再次调用时：</p>
<p><img src="X:\桌面记录文件夹\photototot\PLT.GOT_three.jpeg"></p>
<blockquote>
<p>参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/SVicen/p/16889142.html#plt%E5%92%8Cgot">Pwn学习随笔 - SVicen - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p><strong>调试示例：</strong></p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv)
&#123;
   puts(&quot;hello,world&quot;);
   exit(0);
&#125;
</code></pre>
<pre><code class="assembly">                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .plt          00000040  080482f0  080482f0  000002f0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .plt.got      00000008  08048330  08048330  00000330  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 21 .got          00000004  08049ffc  08049ffc  00000ffc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 22 .got.plt      00000018  0804a000  0804a000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 23 .data         00000008  0804a018  0804a018  00001018  2**2
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 xi &amp; Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;enicky
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        




        
    </body>
</html>
